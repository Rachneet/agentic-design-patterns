# Cheat Sheet: Manual Tool Calling in LangChain

#### Estimated time needed: 20 minutes

## I. What is manual tool calling?

Manual tool calling in LangChain gives you precise control over how external tools are used. Instead of relying on the LLM to autonomously invoke tools, developers parse the LLM's output to extract tool calls, validate inputs, and execute functions manually.

This approach is particularly beneficial in production environments where reliability, security, and auditability are paramount.

## II. Key concepts

| Term | Definition |
|------|------------|
| Tool | A Python function paired with a schema that defines its name, description, and expected arguments. Tools can be created using the @tool decorator or by defining a class inherited from `BaseTool`. |
| Tool Schema | A structured definition (often using Pydantic models) that spells out exactly what input a tool expects. It helps ensure the information is correct and easy to work with. |
| Tool Call | An instruction generated by the LLM indicating which tool to invoke and with what arguments. Typically represented in a structured format like JSON. |
| Automatic Tool Calling | The model autonomously decides to invoke tools based on the input and handles execution without developer intervention. |
| Manual Tool Calling | The developer/user intercepts the model's tool call suggestions, validates inputs, and executes the tools, providing greater control over the process. |
| `AIMessage` | A message type that represents the model's response, which may include tool call instructions in the `.tool_calls` attribute. |
| `ToolMessage` | A message type used to convey the result of a tool execution back to the model, maintaining context and enabling the model to generate informed subsequent responses, containing the tool output and associated `tool_call_id`. |
| tool_call_id | A unique identifier for each tool call, allowing the system to match the tool's output (`ToolMessage`) with the corresponding request (`AIMessage`). This is particularly useful when handling multiple tool calls concurrently. |

## III. How to manually call a tool

Here's a step-by-step look at how you can take control and manually call a tool.

### 1. Define your tools

First, define a simple tool using the handy @tool shortcut.

![Define tools](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/kzOFR8HInxvCcRbalr-LUw/Tab1.png)

### 2. Bind tools to the model

Attach the tools to a chat model that supports tool calling.

![Bind tools](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/h458z44qUFMf0ddmdiH8rQ/Tab2.png)

### 3. Parse tool calls

After invoking the model, parse its output to extract tool calls.

![Parse tool calls](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/8We5lHJNjN6GNKz2jbJ7vw/Tab3-1.png)

This is what tool_calls looks like:

![Tool calls output](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/GBhoJV8KET6llw331L4UOQ/Tab3-2.png)

### 4. Validate tool arguments

Use a Pydantic model or perform a manual check to validate inputs.

![Validate arguments](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/YX3l3Px0_uHPXCvTSA21Vg/Tab4.png)

This is what `validated_input` looks like:

![Validated input](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/cGwYp7ZUlLlnpFMCLUyvpA/Tab5.png)

### 5. Understand tool execution

There are two ways tools return results:

- `tool.invoke(args_dict)` → Returns a raw result (for example, 6)
- `tool.invoke(tool_call_object)` → Returns a ToolMessage automatically

The "manual" part of manual tool calling represents best practices for production tool calling, where you want control over execution:

- **Deciding WHETHER** to execute the tool calls (security, validation, business logic)
- **Choosing WHICH** tools to execute
- **Controlling WHEN** to execute them

When you invoke a LangChain Tool with a `ToolCall` object, you automatically get back a `ToolMessage`, so you don't need to manually create a `ToolMessage` in most cases.

### 6. Purpose of `ToolMessage`

`ToolMessage` is used to maintain context and state throughout the conversation between the user and the model.

`ToolMessages` are essential for feeding tool results back to the LLM so it can continue the conversation. The purpose is **NOT** just getting the tool result, but **feeding that result back to the LLM** so it can:

- See what the tool returned
- **Continue the conversation** with that context
- **Give a final answer** to the user

![ToolMessage purpose](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/LEh-x9IFNX2i1TJvtPll6A/Tab6.png)

When you run the statement below, it's not truly a manual tool calling. It's more like a "semi-automatic" tool calling because the tools are always executed. When you run it, the output is returned wrapped in an `AIMessage`.

![Semi-automatic calling](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/laPLNtG7fLr4JlESEj3dEg/Tab7.png)

### 7. Controlled tool calling

Here is how you can implement controlled tool calling:

![Controlled calling 1](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/UrZraLlgSjTLtstQCkjEWA/Tab8.png)

![Controlled calling 2](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/Q46aiEOXP61E21J_5HKsDQ/Tab9.png)

Let's look at what makes the above code "manual":

#### i. Conditional execution

You decide whether to run the tool. You don't just run every tool the LLM asks for.

![Conditional execution](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/PPBLpaN9Mt9aFVoYHx-Z5Q/Tab10.png)

#### ii. Custom business logic

You've implemented a rule that overrides the LLM's decision. The LLM might want to multiply negative numbers, but you decide it's not allowed.

![Custom business logic](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/7-fx1Ak2CqsIKry5VT6Jmw/Tab11.png)

#### iii. Tool filtering

You can decide which tools are allowed to run. Any tools you don't recognize or approve get skipped.

![Tool filtering](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/7uUtIK9gi7-cbz_xn-_Qbw/Tab12.png)

#### iv. Custom error handling

Instead of letting a tool run and possibly fail, you can proactively reject it with a custom error message that makes more sense to the user.

---
